{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction areInputsEqual(newInputs, lastInputs) {\n  for (var i = 0; i < newInputs.length; i++) {\n    if (newInputs[i] !== lastInputs[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar lastArgs = [];\nvar lastResult = 0;\n\nfunction mergeExtraData() {\n  for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n    newArgs[_key] = arguments[_key];\n  }\n\n  if (areInputsEqual(newArgs, lastArgs)) {\n    return lastResult;\n  }\n\n  lastResult = lastResult === 10 ? 0 : lastResult + 1;\n  lastArgs = newArgs;\n  return lastResult;\n}\n\nexports.default = mergeExtraData;","map":{"version":3,"sources":["C:/Users/dvdra/Desktop/walkthrough/node_modules/react-native-app-intro-slider/dist/merge-extradata.js"],"names":["Object","defineProperty","exports","value","areInputsEqual","newInputs","lastInputs","i","length","lastArgs","lastResult","mergeExtraData","newArgs","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,SAASC,cAAT,CAAwBC,SAAxB,EAAmCC,UAAnC,EAA+C;AAG3C,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,SAAS,CAACG,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AAEvC,QAAIF,SAAS,CAACE,CAAD,CAAT,KAAiBD,UAAU,CAACC,CAAD,CAA/B,EAAoC;AAChC,aAAO,KAAP;AACH;AACJ;;AACD,SAAO,IAAP;AACH;;AACD,IAAIE,QAAQ,GAAG,EAAf;AACA,IAAIC,UAAU,GAAG,CAAjB;;AACA,SAASC,cAAT,GAAoC;AAAA,oCAATC,OAAS;AAATA,IAAAA,OAAS;AAAA;;AAChC,MAAIR,cAAc,CAACQ,OAAD,EAAUH,QAAV,CAAlB,EAAuC;AACnC,WAAOC,UAAP;AACH;;AAEDA,EAAAA,UAAU,GAAGA,UAAU,KAAK,EAAf,GAAoB,CAApB,GAAwBA,UAAU,GAAG,CAAlD;AACAD,EAAAA,QAAQ,GAAGG,OAAX;AACA,SAAOF,UAAP;AACH;;AACDR,OAAO,CAACW,OAAR,GAAkBF,cAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction areInputsEqual(newInputs, lastInputs) {\n    // Using for loop for speed. It generally performs better than array.every\n    // https://github.com/alexreardon/memoize-one/pull/59\n    for (let i = 0; i < newInputs.length; i++) {\n        // using shallow equality check\n        if (newInputs[i] !== lastInputs[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nlet lastArgs = [];\nlet lastResult = 0;\nfunction mergeExtraData(...newArgs) {\n    if (areInputsEqual(newArgs, lastArgs)) {\n        return lastResult;\n    }\n    // Something shallowly changed - return a new number from [0-10]\n    lastResult = lastResult === 10 ? 0 : lastResult + 1;\n    lastArgs = newArgs;\n    return lastResult;\n}\nexports.default = mergeExtraData;\n"]},"metadata":{},"sourceType":"script"}